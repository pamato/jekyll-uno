{
    "collab_server" : "",
    "contents" : "\nload(ac-net-env-case.RData)\n\nlibrary(statnet)\nlibrary(sna)\nlibrary(network)\n\nur analyses utilizes novel network data on all interest groups that coauthored am- icus curiae briefs for 2000â€“2009 Supreme Court cases on natural re- sources and environmental protection. This novel dataset where inter- est groups are tied to one another through coauthoring the same brief captures a purposive and coordinated network of interest groups lob- bying collectively on environmental policy issues. Once the network is assembled, our first step is to focus on the roles of actors within a network. We do so using a novel methodological innovation that ex- tracts the ego-networks for each group, such as the network for the Sierra Club or National Wildlife Federation, from the larger environ- mental advocacy coalition. This allows us to characterize the ego-net- works and find which are similar. These groups are then sorted by whether they play similar roles within the larger environmental inter- est group coalition network.\n\n\n# Descriptive:\n\nnetwork.edgecount(net)\nnetwork.size(net)\nnetwork.vertex.names(net)\n\n\n### Get network\nmat <- as.matrix(net, matrix.type=\"edgelist\")\n\n### Get attributes\n\n# network attr\nlist.network.attributes(net)\nget.network.attribute(net, \"mnext\") # Number of nodes\n\n# node attr\nattributes.list <-list.vertex.attributes(net)\nattributes <- data.frame(sapply(attributes.list, function(x) get.vertex.attribute(net, x)))\nattributes$node_id <- network.vertex.names(net)\n\n# edge\nlist.edge.attributes(net)\n\nget.edge.value(net, \"case1\")\n\nlength(get.edge.attribute(net, \"caseName2\"))\n\nlength(get.edge.attribute(net, \"caseName2\", unlist=TRUE))\n\n## Social Capital\n\n\n\n# Structural Holes\n\n###########################\n#   POSITIONAL ANALYSIS   #\n###########################\n#Burt's (1992) measures of structural holes are supported by iGraph and ego network variants of these measures are supported by egonet\n#...the egonet package is compatable with the sna package.\n  \n#You can find descriptions and code to run Burt's measures in igraph at: http://igraph.org/r/doc/constraint.html\n  \n  #Brokerage: The brokerage measure included in the SNA package builds on past work on borkerage (Marsden 1982), but is a more \n  #...explicitly group oriented measure. Unlike Burt's (1992) measure, the Gould-Fernandez measure requires specifying a group variable\n  #...based on an attribute. I use race in the example below.\n  \n    #Brokerage Roles: Group-Based Concept\n    #w_I: Coordinator Role (Mediates Within Group Contact)\n    #w_O: Itinerant Broker Role (Mediates Contact between Individuals in a group to which the actor does not belong)\n    #b_{IO}: Representative: (Mediates incoming contact from out-group members)\n    #b_{OI}: Gatekeeper: (Mediates outgoing contact from in-group members)\n    #b_O: Liason Role: (Mediates contact between individuals of two differnt groups, neither of which the actor belongs)\n    #t: Total or Cumulative Brokerage (Any of the above paths)\n  ?brokerage   #for more information\n  \n  AHS_Brokerage <- brokerage(AHS_Network, Race)\n  AHS_Brokerage\n  hist(AHS_Brokerage$cl, xlab=\"Cumulative Brokerage\", prob=TRUE) \n  \n  AHS_CBrokerage <- (AHS_Brokerage$cl)\n  gplot(AHS_Network, vertex.cex=AHS_CBrokerage*.5, gmode=\"digraph\") \n  \n#Jimi Adams's Function for Calculating Effective Size\n  #Effective size is the average degree of ego network without counting alters' ties to ego \n  \n  #Detaching to ensure that Statnet and iGraph do not conflict\n  detach(\"package:sna\", unload=TRUE)\n  library(igraph)\n  \n  #Loading Example Data\n  load(\"Flo_Edges.Rda\")\n  load(\"Flo_Nodes.Rda\")\n  \n  g=graph.data.frame(Flo_Edges)\n  V(g)$ego=as.character(Flo_Nodes$ego[match(V(g)$name,Flo_Nodes$ID)])\n  V(g)\n  plot(g, vertex.label=Flo_Nodes$ego, \n       edge.arrow.size=.05, edge.arrow.width=.05,\n       vertex.size=degree(g,mode = \"in\"))\n  \n  effective.size <- function(g, ego, mode=\"all\") {\t\t# igraph doesn't have an \"effective size\" command\n    n <- degree(g, mode=mode)[ego]\t\t\t\t\t\t        # ego's degree\n    es <- n\t\t\t\t\t\t\t\t\t\t\t\t                    # initializing effective size\n    ns <- neighbors(g,ego, mode=mode)\t\t\t\t\t        # identifying ego's neighborhood\n    if(n>0){\n      for (j in 1:n){\t\t\t\t\t\t\t\t\t                # looping over everyone in ns\n        nsns <- neighbors(g,ns[j], mode=mode)\t\t      # finding neighbors' neighbors\n        r <- length(intersect(ns, nsns))\t\t\t        # only those also in ego's neighborhood\n        es <- es - (r/n)\t\t\t\t\t\t\t                # subtracting redundancies\n      }\n    }\n    return(es)\n  }\n  \n  effective.size(g, \"9\", mode=\"all\")\n  \n  #Trying on Our School Networks\n  AHS_Graph=graph.data.frame(AHS_Edges)\n  effective.size(AHS_Graph, \"1\", mode=\"all\")\n  \n#Jimi Adams's Function for Calculating the Index of Qualitative Variatio\n  #The index of qualitative variation (IQV) is a measure of variation among the categories\n  #of a qualitative variable.  \n  #It is calculated as [1 - sum(p2)]  * [K / (K - 1)], \n  #where p is the proportion in each category, and K is the number of categories. \n  #The variable ranges from 0 to 1, where 0 represents a completely homogeneous group,\n  #and 1 represents a group with equal parts in each category.\n  \n  iqv <- function(graph, attribute) {\n    require(igraph)\n    N <- length(V(graph))\n    cats <- unique(get.vertex.attribute(graph,attribute,V(graph)))\n    nlev <- length(cats)\n    cat_list <- rep(0,N)\n    p <- rep(0, N) \n    p2_list <- as.list(0)\n    for (j in 1:nlev) {\n      for(i in 1:length(V(graph))){\n        i_att <- get.vertex.attribute(graph, attribute, V(graph)[neighborhood(graph,1)[[i]]]) \n        att <- length(which(i_att==cats[j]))\n        num <- length(V(graph)[neighborhood(graph, 1)[[i]]])\n        p[i]<-att/num\n        p2<-p*p\n      }\n      p2_list[[j]] <- p2\n      cat_list <- cat_list + p2\n    }\n    IQV <- (nlev/(nlev-1))*(1-cat_list)\n    IQV1 <- as.list(0)\n    IQV1[[2]] <- IQV\n    IQV1[[1]] <- mean(IQV)\n    names(IQV1) <- c(\"full_graph\", \"egonet\")\n    return (IQV1)\n    detach(\"package:igraph\", unload=TRUE)\n  } \n  \n  #Assigning Attributes\n  AHS_Graph <- AHS_Graph %>%\n    set_vertex_attr(\"sex\", value = AHS_Nodes$sex) %>%\n    set_vertex_attr(\"grade\", value = AHS_Nodes$grade)\n  \n  V(AHS_Graph)\n  \n  #This function takes some time to calculate for a network of this size\n  #because you are calculating the variation ratio for each person \n  #in a passed complete network, for a single attribute at a time.\n  iqv(AHS_Graph, \"sex\")\n  \n#Detaching to ensure that Statnet and iGraph do not conflict\n  detach(\"package:igraph\", unload=TRUE)\n  library(sna)\n\n\n\n# E-I Index\n  # Homophily\n  # Differential homophily\n  # Heterogeneity\n    # Blau index\n    # IQV index\n\n# Brokerage Roles\n  # Matrix of Actor to Brokerages --> run MDS\n\n\n# Structural Equivalences\n\n#Structural Equivalence\n  #Structural equivalence: Similarity/Distance Measures Include:\n    #Correlation\n    #Euclidean Distance\n    #Hamming Distance\n    #Gamma Correlation\n  sedist(AHS_Network, mode=\"digraph\", method=\"hamming\")\n  \n  #Cluster based on structural equivalence:\n  AHS_Clustering <- equiv.clust(AHS_Network, mode=\"digraph\",plabels=network.vertex.names(AHS_Network))\n  AHS_Clustering                        #Specification of the equivalence method used\n  plot(AHS_Clustering)                  #Plot the dendrogram\n  rect.hclust(AHS_Clustering$cluster, h=30)\n  \n  #Generating a Block Model based on the Structural Equivalence Clustering\n  AHS_BM <- blockmodel(AHS_Network, AHS_Clustering, h=30)\n  AHS_BM\n    \n  #Extract the block image for Visualization\n  bimage <- AHS_BM$block.model\n  bimage\n  bimage[is.nan(bimage)] <- 1\n  \n  #Visualizing the block image (with self-reflexive ties)\n  gplot(bimage, diag=TRUE, edge.lwd=bimage*5, vertex.cex=sqrt(table(AHS_BM$block.membership))/2,\n        gmode=\"graph\", vertex.sides=50, vertex.col=gray(1-diag(bimage)))\n  \n",
    "created" : 1558185567977.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "120|37|146|2|\n",
    "hash" : "3545875877",
    "id" : "69BCA167",
    "lastKnownWriteTime" : 1558189902,
    "last_content_update" : 1558416949842,
    "path" : "~/Downloads/social capital lab.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}