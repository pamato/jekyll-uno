{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Introduction to Social Network Analysis - Lab 2\"\nauthor: \"Paulo Serôdio\"\noutput:\n  html_document:\n    theme: readable\n    highlight: zenburn\n    code_folding: show\n    df_print: kable\n    number_sections: yes\n    toc: yes\n    toc_float:\n      collapsed: no\n---\n\n\nStart from clean slate and free up memory\n\n```{r tidy=TRUE, results=FALSE}\nrm(list = ls())\ngc()\n```\n\nLoad R packages\n\n```{r, message=FALSE, warning=FALSE}\nlibrary(statnet)\nlibrary(sna)\nlibrary(network)\nlibrary(tidyverse)\n```\n\n\n\n```{r}\n## Load data\n\nload(\"./data/ac-net-env-case.RData\")\n```\n\n\n- Novel network dataset on all 275 interest groups that coauthored amicus curiae briefs for 2000–2009 Supreme Court cases on natural resources and environmental protection.\n- Ties are determined by whether two groups have cosigned a brief on the same case at least once;\n- A reviewer noted that this is naturally a value-edged network as groups can coauthor on multiple briefs during the 2000–2009 period. We make the decision to binarize this network;\n- Amicus curiae briefs, or ``friend of the court briefs'', reflect the public position of a particular entity not involved in a court case with respect to the issues being heard.\n- Their purpose is to provide evidence, opinion, and testimony that the parties directly involved in the case may not provide. Amicus curiae partic- ipation requires a statement on the position of a group, and cosign- ing the same brief indicates coordinated efforts with a shared purpose.\n- This novel dataset where interest groups are tied to one another through coauthoring the same brief captures a purposive and coordinated network of interest groups lobbying collectively on environmental policy issues. Once the network is assembled, our first step is to focus on the roles of actors within a network. \n\n\n\n```{r}\n\n# Number edges:\nnetwork.edgecount(net)\n\n# Number of nodes:\nnetwork.size(net)\n\n# Node IDs\nnetwork.vertex.names(net)[1:10]\n\n```\n\nConvert `network` object into edgelist\n\n```{r}\nmat <- as.matrix(net, matrix.type=\"edgelist\")\n```\n\nCheck for attributes\n\n```{r}\n# network attr\nlist.network.attributes(net)\nget.network.attribute(net, \"mnext\") # Number of nodes\n\n# node attr\nlist.vertex.attributes(net)\n\n# edge\nlist.edge.attributes(net)\nget.edge.attribute(net, \"case1\")\n```\n\nRetrieve all node attributes and store in data.frame\n\n```{r}\nattributes.list <-list.vertex.attributes(net)\nattributes <- data.frame(sapply(attributes.list, function(x) get.vertex.attribute(net, x)))\nattributes$node_id <- network.vertex.names(net)\n\n```\n\nRetrieve all edge attributes and store in data.frame (these are essentially multiple edgelists)\n```{r}\n# Get edge attributes (list of amicus briefs SIGs signed together)\nedgeatttr.list <- list.edge.attributes(net)\nedge.attributes <- as.matrix(sapply(edgeatttr.list, function(x) get.edge.attribute(net,x)))\n# Add edge attributes to edge.list\ncomplete.matrix <- data.frame(cbind(mat, edge.attributes))\ncolnames(complete.matrix)[1:2] <- c(\"source\", \"target\")\n# Create edge weight = count of number of amicus briefs co-signed for edge dyad\ncomplete.matrix$edge_value <- rowSums(sapply(colnames(complete.matrix[grep(\"(case)[[:digit:]]\", names(complete.matrix))]), function(x) ifelse(is.na(complete.matrix[[x]]), 0, 1)))\nvalued.mat <- complete.matrix[, c(1,2,ncol(complete.matrix))]\nvalued.mat[1:10,]\n```\n\n\n\n```{r, echo=FALSE}\nkableExtra::kable(head(attributes)) %>%\n  kableExtra::kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\", full_width = FALSE))\n\n```\n\n\n\n# Embeddedness and bridging\n\n\nBreiger & Pattison (1986), in their discussion of local role analysis, use a subset of data on the social relations among Renaissance Florentine families (person aggregates) collected by John Padgett in 1994 from historical documents. The two relations are business ties (flobusiness - specifically, recorded financial ties such as loans, credits and joint partnerships) and marriage alliances (flomarriage).\n\nAs Breiger & Pattison point out, the original data are symmetrically coded. This is acceptable perhaps for marital ties, but is unfortunate for the financial ties (which are almost certainly directed). To remedy this, the financial ties can be recoded as directed relations using some external measure of power - for instance, a measure of wealth. Both networks provide vertex information on (1) wealth each family's net wealth in 1427 (in thousands of lira); (2) priorates the number of priorates (seats on the civic council) held between 1282- 1344; and (3) totalties the total number of business or marriage ties in the total dataset of 116 families (see Breiger & Pattison (1986), p 239).\n\nSubstantively, the data include families who were locked in a struggle for political control of the city of Florence in around 1430. Two factions were dominant in this struggle: one revolved around the infamous Medicis (9), the other around the powerful Strozzis (15).\n\n```{r}\nlibrary(tidyverse)\n# if you're interested in exploring the complete dataset, check it here\nflorentine.families <- rio::import(\"./data/florentine_families_relations_full.xlsx\")\n# Group by family surname and sum over ties\nflo.marriage.fam <- florentine.families %>% filter(Relationship_type==\"Marriage\") %>% group_by(sender=tolower(Actor1surname), receiver=tolower(Actor2surname)) %>% summarise(Tie_coding= n())\nflo.g <- igraph::graph_from_data_frame(flo.marriage.fam)\nigraph::V(flo.g)$color <- as.factor(igraph::V(flo.g)$name)\n# Plot\nigraph::plot.igraph(flo.g, vertex.label=NA, vertex.size = 5, layout=igraph::layout.fruchterman.reingold,\n                    edge.arrow.size=0.2)\n```\n\n```{r}\n# We'll analyze a subset of this data\ndata(florentine)\n# Bring attribute data for subset of the network\nflo.attr <- rio::import(\"./data/florentine_attributes_subset.xlsx\")\ng <- snatools::as_igraph(flomarriage)\nigraph::V(g)$faction <- as.character(flo.attr$faction[order(flo.attr$family)])\n# Color the party factions\nigraph::V(g)$color <- igraph::V(g)$faction\nigraph::V(g)$color <- gsub(\"medici\",\"gold\",igraph::V(g)$color) # Medici are gold\nigraph::V(g)$color <- gsub(\"oligarchs\",\"blue\",igraph::V(g)$color) # Oligarchs are blue\nigraph::V(g)$color <- gsub(\"split\",\"gray70\",igraph::V(g)$color) # Split affiliat ion is gray\nigraph::V(g)$color\nigraph::plot.igraph(g, layout=igraph::layout.fruchterman.reingold, vertex.label.cex=0.75)\n```\n\n## Cutpoints\n\n```{r}\ng %>%\n  igraph::articulation_points() %>%\n  as.list() %>%\n  names() %>%\n  as.data.frame() %>%\n  `colnames<-`(\"Cut Points\")\n\nigraph::V(g)$color = ifelse(igraph::V(g) %in% igraph::articulation_points(g), \"salmon\", \"lightblue\")\nplot(g, vertex.label.cex=.75, edge.width = 5)\n\n\n```\n\n## Weak ties & Reachability\n\nWe will look at the neighbourhood of a node, two or three steps out. Below, we generate a function to count the number of neighbours at two and three steps out:\n\n```{r}\n\n# Function for 2-step reach\nreach2<-function(x){ \n          r=vector(length=igraph::vcount(x)) \n          for (i in 1:igraph::vcount(x)){ \n            n=igraph::neighborhood(x,2,nodes=i) \n            ni=unlist(n)\n            l=length(ni)\n            r[i]=(l)}\n          r}\n\n# Function for 3-step reach \nreach3<-function(x){\n          r=vector(length=igraph::vcount(x)) \n          for (i in 1:igraph::vcount(x)){ \n            n=igraph::neighborhood(x,3,nodes=i) \n            ni=unlist(n)\n            l=length(ni)\n            r[i]=(l)}\n          r}\n\nReach_2 <- reach2(g) \nReach_3 <- reach3(g) \n```\n\nTo see how many **weak ties** each node has, we first need to calculate how many nodes are in each node’s neighborhood at two steps out (`reach2`). Then, we need only subtract the number of nodes that are ajacent to the node (`degree).\n\n```{r}\nReach_2 - igraph::degree(g)\n```\n\n\n# Roles & Positions\n\n- Examining roles through the a networks-based lens can explain why actors select into a network, how certain organizations benefit the larger collective, and the dynamics that influence successful lobbying. \n- Roles emerge from structural features of a community and reflect commonalities in behavior. \n- detecting the structural position of nodes within a network allows for statements about the roles that actors adopt.\n- Take for example, the roles that states may adopt in international politics. Many theories of interna- tional politics are intrinsically about the roles that states may adopt when interacting with one another. Consider balance of power the- ory, a hallmark of international relations describing how states at- tempt to preserve their security by balancing stronger states. This the- ory is intrinsically about the roles that states may adopt as aggres- sors, defenders, or balancers\n- these roles greatly influence their behavior and broader sys- tem-level dynamics, making them more prone to war or peace, or more influential in the development of international norms.\n\n\n## Burt's **Structural Holes** (Topological)\n\nBurt's (1992) measures of **structural holes** are supported by iGraph and ego network variants of these measures are supported by `egonet`; this package is compatable with the `sna` package.\n\nHowever, `egonet` has been removed from CRAN. So, we install it locally from an older version.\n\n```{r}\ninstall.packages(\"./packages/egonet\", repos = NULL, type = \"source\")\n?egonet::`egonet-package`\n```\nA small tool for Social Network Analysis, dealing with ego-centric network measures, including Burt's effective size and aggregate constraint and an import code suitable for a large number of adjacency matrices.\n\nThe Egonet package is also available as free web application on http://www.egonet.associazionerospo.org (and an example of output can be seen here: http://www.egonet.associazionerospo.org/egonetdata/EgonetOutput.htm)\n\n\n\n+ Using **data from grant applications** made between 2012 and 2013 by faculty in a a major US university\n\n```{r}\nyear <- seq(2012, 2013, by=1)\nfor (y in year){\n  edgelist.name <- paste(\"matrix\", y, sep=\".\")\n  attr.name <- paste(\"attr\", y, sep=\".\")\n  net.name <- paste(\"net\", y, sep=\".\")\n  edgelist.data <- as.matrix(table(rio::import(paste(\"./data/edgelist\", y, \".dta\", sep=\"\"))))\n  edgelist.data <- edgelist.data %*% t(edgelist.data)\n  diag(edgelist.data) <- 0\n  edgelist.data[edgelist.data > 1] <- 1\n  attr.data <- rio::import(paste(\"./data/attr\", y, \".dta\", sep=\"\"), convert.factors=F)\n  network <- network::network(edgelist.data, directed=FALSE,ignore.eval=FALSE,names.eval='grants')\n  #edgelist.data <- edgelist.data[-isolates(network), -isolates(network)] # remove isolates\n  #attr.data <- attr.data[-]\n  assign(edgelist.name, value = edgelist.data)\n  assign(attr.name, value=attr.data)\n  assign(net.name, value=network)\n  rm(edgelist.data, attr.data, attr.name, edgelist.name, network, net.name)\n}\n```\n\n```{r }\n\n# Remove isolates\nmat12 <- matrix.2012[-sna::isolates(net.2012), -sna::isolates(net.2012)]\nattributes.12 <- attr.2012[-c(sna::isolates(net.2012)),]\nmat13 <- matrix.2013[-sna::isolates(net.2013), -sna::isolates(net.2013)]\nattributes.13 <- attr.2013[-c(sna::isolates(net.2013)),]\n```\n\n\n```{r }\n# Extract ego-networks and calculate measures\nego.nets.12 <- sna::ego.extract(mat12, neighborhood=\"combined\")\nresults.12 <- data.frame(piid = attributes.12$piid, gender = attributes.12$gender, ego=NA,\n                      effsize = NA, constraint = NA, efficiency = NA, hierarchy = NA, size = NA)\nfor (i in 1:length(ego.nets.12)){\n  ego <- names(ego.nets.12[i])\n  ego.net <- ego.nets.12[i][[1]]\n  dimnames(ego.net) <- NULL\n  colnames(ego.net) <- rownames(ego.net) <- c(\"EGO\", 2:ncol(ego.net))\n  # Get structural holes measures from egonet package\n  sh <- egonet::index.egonet(ego.net)\n  results.12$size[i] <- nrow(ego.net)-1\n  results.12$ego[i] <- ego\n  results.12$effsize[i] <- sh[1]\n  results.12$constraint[i] <- sh[2]\n  results.12$efficiency[i] <- sh[5]\n  results.12$hierarchy[i] <- sh[6]\n}\n\n# Store average SH mesaures by some attribute\n\neffsize.g <- results.12 %>% group_by(gender) %>% summarise(mean = mean(effsize))\nconstraint.g <- results.12 %>% group_by(gender) %>% summarise(mean = mean(constraint))\nefficiency.g <- results.12 %>% group_by(gender) %>% summarise(mean = mean(efficiency))\nhierarchy.g <- results.12 %>% group_by(gender) %>% summarise(mean = mean(hierarchy))\nsize.g <- results.12 %>% group_by(gender) %>% summarise(mean = mean(size))\n\n# Push the results\ntable(results.12$size[results.12$gender == \"Female\"])\ntable(results.12$size[results.12$gender == \"Male\"])\nplot(density(results.12$size[results.12$gender == \"Male\"]))\nplot(density(results.12$size[results.12$gender == \"Female\"]))\n\n```\n\n\n\n## Brokerage (Gould & Fernandez topology+attributes)\n\nThe brokerage measure included in the `sna` package (hint: it needs a `network` object) builds on past work on borkerage (Marsden 1982), but is a more explicitly group oriented measure. Unlike Burt's (1992) measure, the Gould-Fernandez measure requires specifying a group variable based on an attribute. We will use race in the example below.\n  \n**Brokerage Roles*: a group-based concept\n\n  - `w_I`: **Coordinator**, mediates Within Group Contact ($A \\rightarrow A \\rightarrow A$)\n  - `w_O`: **Itinerant Broker**/**Consultant**, mediates contact between individuals in a group to which the actor does not belong ($A \\rightarrow B \\rightarrow A$) \n  - `b_{IO}`: **Representative**, mediates incoming contact from out-group members ($A \\rightarrow B \\rightarrow B$)\n  - `b_{OI}`: **Gatekeeper**, mediates outgoing contact from in-group members, ($A \\rightarrow A \\rightarrow B$)\n  - `b_O`: **Liason Role**, mediates contact between individuals of two differnt groups, neither of which the actor belongs, ($A \\rightarrow B \\rightarrow C$)\n  - `t`: Total or Cumulative Brokerage (total number of time a node fills any of the above roles)\n\nIf you run the function without `$raw.nli` appended to the end, you will see that it produces fourteen different forms of output. It is worth mentioning that you can also produce a normalized score that will give the magnitude of the differences between nodes, rather than the raw number of times. Use this approach if you prefer to simplify the table by displaying how the nodes differ by order of magnitude.\n\nThe brokerage function does this by providing normalized output that is scaled on the z distribution, referred to \"z scores\". Z scores are calculated by comparing each number to the average for the distribution and dividing by the standard deviation.\n\n$$z = \\frac{x - \\bar{x}}{s}$$\nIn the results you'll encounter both positive and negative valyes (the scale is cetered at 0). Consider that anything grater than 1.96 or less than -1.96 (2 sd away from the mean) is significantly different from the \"typical\" at p=0.05 level of significance. This is helpful to identify the nodes that stand out by being statistically significantly greater/less than the average for the network.\n\nTo produce normalized scores add `z.nli` to the function. Use `round()` to reduce number of digits.\n\n\nType `?brokerage` for more information\n  \n\n+ **Using faculty grant application data**\n\n```{r, eval=FALSE, include=FALSE}\n### Brokerage Roles ###\nmat12 <- matrix.2012[-isolates(net.2012), -isolates(net.2012)]\nattributes.12 <- attr.2012[-c(isolates(net.2012)),]\n\n\n# Gender Brokerage; observed scores\nbrokerage.12 <- brokerage(mat12, attributes.12$gender)\nsummary(brokerage.12)\npositions <- data.frame(brokerage.12$z.nli) # Raw Observed Brokerage Scores by vertex\ncolnames(positions) <- c(\"piid\", \"coordinator\", \"consultant\", \"representative\",\n                         \"gatekeeper\", \"liaison\")\npositions$gender <- attributes.12$gender\n\ncoord <- ddply(positions, .(gender), summarize, sum=mean(coordinator))\nconsul <- ddply(positions, .(gender), summarize, sum=mean(consultant))\nrep <- ddply(positions, .(gender), summarize, sum=mean(representative))\ngate <- ddply(positions, .(gender), summarize, sum=mean(gatekeeper))\nliaison <- ddply(positions, .(gender), summarize, sum=mean(liaison))\n```\n\n\n+ ** Using Add Health data **\n\n```{r}\n# Import data, create network object\nAHS.Nodes <- load(\"./data/AHS_nodes.Rda\")\nAHS.Edges <- load(\"./data/AHS_edges.Rda\")\nahs.net <- network::network(AHS_Edges, matrix.type = \"edgelist\")\nnetwork::set.vertex.attribute(ahs.net, \"Race\", AHS_Nodes$race5)\n\n# Calculate roles & position counts\nAHS_Brokerage <- sna::brokerage(ahs.net, \"Race\")\n# Raw scores\nhead(AHS_Brokerage$raw.nli)\n# Raw and Normalized scores rounded to 2 digits\nhead(round(AHS_Brokerage$z.nli, 2))\n```\n\n\n# Homophily & Heterogeneity\n\n## E-I index\n\n$$ \\textbf{E-I Index} = \\frac{E - I}{E + I} $$\n*E-I Index* was proposed by Krackhard and Stern (1988) to capture relative prevalence of between- and within-group ties. From that perspective it can be interpreted as a measure of network segregation.\n\nThe E-I Index is not common to many R packages, and it is not as simple as it seems to program. To make your life simpler, it is necessary to first install a package called `isnar`, written and maintained by Michal Bojanowski as a supplement to `igraph`. It is only available through Git Hub, as it's an R package in development.\n\n```{r, eval=FALSE, message=FALSE, warning=FALSE}\ndevtools::install_github(\"mbojan/isnar\")\n\n```\n\n\nThe generic method for using the E-I Index in isnar is `ei(g, \"attribute\")` , where `g` is an igraph object, with a qualitative attribute (`attribute`) assigned to each of the vertices.\n\n```{r}\n# Convert our Add Health network object to igraph\nahs.g <- snatools::as_igraph(ahs.net)\n# Run E-I Index\nisnar::ei(ahs.g, \"Race\")\nplot(g, layout=igraph::layout.fruchterman.reingold, vertex.label=NA)\n```\n\n\n\n## Index of Qualitative Variation\n\nThe index of qualitative variation (IQV) is a measure of variation among the categories of a qualitative variable. It is calculated as\n\n$$ 1 - \\sum p_2 * (\\frac{k}{k-1})$$ ,\n\nwhere $p$ is the proportion in each category, and K is the number of categories. The variable ranges from 0 to 1, where 0 represents a completely homogeneous group, and 1 represents a group with equal parts in each category.\n\nThe function below also returns Blau's index. It takes as input a matrix and an attribute vector.\n\n```{r}\nget_iqvs <- function(matrix, attribute) {\n \n    mat <- matrix\n    attr_levels = attribute\n    num_levels = length(unique(attr_levels))\n    iqvs = rep(0, nrow(mat))\n    blau_index = rep(0, nrow(mat))\n \n    for (ego in 1:nrow(mat)) {\n         \n        # initialize actor-specific variables\n        alter_attr_counts = rep(0, num_levels)\n        num_alters_this_ego = 0\n        sq_fraction_sum = 0\n     \n        for (alter in 1:ncol(mat)) {\n             \n            # only examine alters that are actually tied to ego\n            if (mat[ego, alter] == 1) {\n                 \n                num_alters_this_ego = num_alters_this_ego + 1\n \n                # get the alter's level on the attribute \n                alter_attr = attribute[alter]\n \n                # increment the count of alters with this level\n                # of the attribute by 1\n                alter_attr_counts[alter_attr] <- alter_attr_counts[alter_attr] + 1\n            }\n        }\n \n         for (i in 1:num_levels) {\n            attr_fraction = alter_attr_counts[i] /\n                num_alters_this_ego\n            sq_fraction_sum = sq_fraction_sum + attr_fraction ^ 2\n        }\n         \n        # now we can compute the ego's blau index...\n        blau_index[ego] = 1 - sq_fraction_sum\n        # and the ego's IQV, which is just a normalized blau index\n        iqvs[ego] = blau_index[ego] / (1 - (1 / num_levels))\n    }\n \n    return(list(iqvs, blau_index))\n}\n```\n\n```{r}\nahs.mat <- igraph::as_adjacency_matrix(ahs.g)\nahs.attr <- igraph::get.vertex.attribute(ahs.g)$Race\n\nahs_iqv <- get_iqvs(ahs.mat, ahs.attr)[[1]]\nahs_blau <- get_iqvs(ahs.mat, ahs.attr)[[2]]\n```\n\nIf you prefer to use an `igraph` object, use the following function.\n**Warning**: it will deploy `igraph` into the environment. Prepare for conflicts.\nTAKE SHELTER!\n\n```{r}\niqv <- function(graph, attribute) {\n    require(igraph) \n    N <- length(igraph::V(graph))\n    cats <- unique(igraph::get.vertex.attribute(graph,attribute,igraph::V(graph)))\n    nlev <- length(cats)\n    cat_list <- rep(0,N)\n    p <- rep(0, N) \n    p2_list <- as.list(0)\n    for (j in 1:nlev) {\n      for(i in 1:length(igraph::V(graph))){\n        i_att <- igraph::get.vertex.attribute(graph, attribute, igraph::V(graph)[igraph::neighborhood(graph,1)[[i]]]) \n        att <- length(which(i_att==cats[j]))\n        num <- length(igraph::V(graph)[igraph::neighborhood(graph, 1)[[i]]])\n        p[i]<-att/num\n        p2<-p*p\n      }\n      p2_list[[j]] <- p2\n      cat_list <- cat_list + p2\n    }\n    IQV <- (nlev/(nlev-1))*(1-cat_list)\n    IQV1 <- as.list(0)\n    IQV1[[2]] <- IQV\n    IQV1[[1]] <- mean(IQV)\n    names(IQV1) <- c(\"full_graph\", \"egonet\")\n    return (IQV1)\n    detach(\"package:igraph\", unload=TRUE)\n  } \n```\n\n```{r, eval=FALSE}\nV(ahs.g)$iqv <- iqv(ahs.g, \"Race\")\n```\n\n\n- IQV using grant activity data\n\n```{r}\n# Prepare data with two attributes: gender and department\n### Data\nmat12 <- matrix.2012[-isolates(net.2012), -isolates(net.2012)]\nmat13 <- matrix.2013[-isolates(net.2013), -isolates(net.2013)]\nattributes.12 <- attr.2012[-c(isolates(net.2012)),]\nattributes.13 <- attr.2013[-c(isolates(net.2013)),]\n## Attributes\ndep.12 <- as.numeric(as.factor(attributes.12$department))\ngender.12 <- as.numeric(as.factor(attributes.12$gender))\n```\n\n```{r}\n# Run IQV and plot\n## Inter-disciplinary heterogeneity by gender\n\niqv.dep <- get_iqvs(mat12, dep.12)[[1]] ## Heterogeneity by discipline\niqv.male <- iqv.dep[gender.12 == 2]\niqv.female <- iqv.dep[gender.12 == 1]\niqv.male.mean <- mean(iqv.dep[gender.12 == 2]) # 0.395\niqv.female.mean <- mean(iqv.dep[gender.12 == 1]) # 0.397\niqv.male.sd <- sd(iqv.dep[gender.12 == 2]) # 0.344\niqv.female.sd <- sd(iqv.dep[gender.12 == 1]) # 0.353\nheterogeneity <- data.frame(gender = attributes.12$gender,iqv = 0)\nheterogeneity$iqv[which(attributes.12$gender == \"Male\")] <- iqv.male\nheterogeneity$iqv[which(attributes.12$gender == \"Female\")] <- iqv.female\nmeans <- data.frame(measure = heterogeneity$iqv, cond = heterogeneity$gender)\nmeans <- means %>% group_by(cond) %>% summarise(cent.mean=mean(measure))\n\n\n# Plot\nggplot(data = heterogeneity, aes(x = iqv, fill=gender)) +\n            #geom_histogram(alpha=.5, position=\"identity\") +\n            geom_density(alpha=.7) + \n            geom_vline(data=means, aes(xintercept=means$cent.mean),  colour=c(\"#FF8585\", \"#19A3FF\"),\n            linetype=\"dashed\", size=1, alpha=.7) + ylim(0,3.2) + xlim(0,1) + \n            theme(axis.text.x = element_text(angle = 45, hjust = 1),\n            axis.title.y = element_text(size=14), axis.title.x  = element_text(size=12)) +\n            xlab(\"Heterogeneity Index\") + ylab(\"\") + ggtitle(\"2012\") + ylab(\"Density\") +\n            scale_fill_manual(name = \"Gender\", values = c(\"#FF8585\", \"#19A3FF\"))\n```\n\n\n# Equivalences\n\n\n## Structural Equivalence with CONCOR\n\nThe original **CONCOR** algorithm was developed by Ron Breiger, Scott Boorman, and Phipps Arabie. If you are interested, you can check out their original (1975) paper: [“An Algorithm for Clustering Relational Data with Applications to Social Network Analysis and Comparison with Multidimensional Scaling. Journal of Mathematical Psychology, 12: 328– 383.](http://sci-hub.tw/https://doi.org/10.1016/0022-2496(75)90028-0). The original version was written in Fortran. Since then, Adam Slez has rewritten the program in R.\n\nAlthough it was developed with structural equivalence in mind, CONCOR is used for equivalence in general, since we rarely expect to see true structrual equivalence in a network.\nBecause Adam Slez has not committed his `concoR` package to CRAN, we will have to install it from his github site. You will only have to do this once.\n\nCONCOR requires a matrix, or stack of matrices to make its calculations. So, start by loading concoR and extracting a matrix from\nan igraph network.\n\n\n```{r eval=F, echo=F}\n#library(concoR)\n# Florentine families in igraph\ng <- snatools::as_igraph(flomarriage)\n# Florentine families in network\nnet <- flomarriage\n# Convert the network to a matrix\nmat <- as.matrix(igraph::get.adjacency(g))\n```\n\n* Using **Roethlisberger & Dickson Bank Wiring Room** \n\n- These are the observational data on 14 Western Electric (Hawthorne Plant) employees from the bank wiring room first presented in Roethlisberger & Dickson (1939). The data are better known through a scrutiny made of the interactions in Homans (1950), and the CONCOR analysis presented in Breiger et al (1975).\n\n- The employees worked in a single room and include two inspectors (I1 and I3), three solderers (S1, S2 and S3), and nine wiremen or assemblers (W1 to W9). The interaction categories include: RDGAM, participation in horseplay;  RDCON, participation in arguments about open windows;  RDPOS, friendship;  RDNEG, antagonistic (negative) behavior; RDHLP, helping others with work; and RDJOB, the number of times workers traded job assignments.\n\n```{r}\n# load Bank Wiring dataset: \n\nnet <- flomarriage\ndata(bank_wiring)\nbank.wiring.net <- sna::as.sociomatrix.sna(net)\ngplot(bank.wiring.net)\n\n```\n\nNext, run the concoR algorithm to identify the various structrual equivalence \"blocks\".\n\nFunctional note: The `list()` function in `concor_hca` is necessary if you are using only one matrix. The program was developed to work with `arrays` (lists of matrices), so it doesn’t play well with single matrices without this command.\n\n```{r}\nblks <- concoR::concor_hca(bank_wiring, p=2)\nblks\n```\n\nThe output gives the vertex names, as well as the \"blocks\" or classes that each vertex was classified into. We can visualize this information in one of two ways: as a block matrix, or as a network visualization. We’ll do each below.\n\nFirst, we can plot the network in `statnet`, using the `blockmodel` function. Note: we input the `network` object for the Florentine network along with the output of the `concor_hca` function.\n\n \n \n```{r}\nblk_mod <- sna::blockmodel(net, blks$block)\nblk_mod\n```\n\n* Plot as a blockmodel matrix\n\n```{r}\nplot(blk_mod)\n```\n\n* Plot as a network\n\n```{r}\n# Add the block designations to igraph data\nigraph::V(g)$blocks <- blks$block\nigraph::plot.igraph(g, vertex.color=igraph::V(g)$blocks) \n```\n\n### Optimization\n\n\nAleš Žiberna has written the `blockmodeling` package on `R`.\n\n```{r, eval=FALSE}\ninstall.packages(\"blockmodeling\")\ninstall.packages(\"./packages/rngtools\", repos = NULL, type = \"source\")\n```\n\n```{r, eval=FALSE, message=FALSE, warning=FALSE}\nlibrary(blockmodeling)\n```\n\nThe \"optimization\"\" approach is where you assign some number of random partitions and require the algorithm to re-sort the network to a point where the various blocks contain a best fit to the network. There are a number of possible options for soting the network under the command. Here, we use the sum of squares methods. Also, the command asks the algorithm to find “complete” blocks (all 1s, and no 0s) if possible. Try it with and without this.\n\nFor more information see [ŽIBERNA, Aleš (2007): Generalized Blockmodeling of Valued Networks. Social Networks, Jan. 2007, vol. 29, no. 1, 105-126](https://sci-hub.se/http://dx.doi.org/10.1016/j.socnet.2006.04.002).\n\n```{r, eval=FALSE}\n# Extract the matrix in igraph\nmat <- as.matrix(get.adjacency(g)) \n# Try a two block partition.\nclass2 <- blockmodeling::opt.random.par(M=mat, k=2, rep=10, approach=\"ss\", blocks=\"com\")\n# Tru a four block partition\nclass4 <- opt.random.par(M=mat, k=4, rep=10, approach=\"ss\", blocks=\"com\")\n```\n\n```{r, eval=F}\npar(mfrow=c(1,2)) # set the plot window for one row and\n two columns\nplot(class2, main=\"\")\n  title(\"Two Block Partition\")\nplot(class4, main=\"\")\n  title(\"Four Block Partition\")\npar(mfrow=c(1,1)) # reset the plot window back to one ro\nw and one column\n```\n\n```{r, eval=F}\n# See what is packed into the outpute object\nls(class4)\nclass4$best  #  Look inside \"best\"\n# The best partition can therefore be found in:\nclass4$best$best1$clu\n```\n\nWe can use the partition the same way we did in `concoR` . Add the partition to the network and plot it in `igraph`.\n\n```{r, eval=F}\n# Add the block designations to igraph data\nV(g)$opt.blocks <- class4$best$best1$clu\nplot.igraph(g, vertex.color=V(g)$opt.blocks) # plot in i\ngraph\n```\n\n\n### Euclidean Distances\n\nEuclidean distance is a method of calculating similarities by comparing common distances from some nodes to other nodes. It may be used for either structural equivalence or automorphic equivalence.\nBelow is a modification of what Carter Butts wrote into `sna`.\n\n```{r}\n#Cluster based on structural equivalence\n# BEWARE: The blockmodeling package interferes with this function.\n# Detach blockmodeling before you begin. detach(\"package:blockmodeling\", unload=TRUE)\neq<-sna::equiv.clust(net,method=\"euclidean\",mode=\"graph\")\n# Form a blockmodel\nb<-sna::blockmodel(net, eq, h=4, mode = \"graph\") # h = 4 is the highest you can go for Medici\nplot(b)      # Plot it\n```\n\n\n## Regular Equivalence\n\n### REGE\n\nREGE is actually a set of algorithms that compute similarities - or dissimilarities - between vertices that equate to regular equivalence.\n\n`REGE`, `REGE.for` - Classical REGE or REGGE, as also implemented in Ucinet. Similarities in terms of regular equivalence are computed. The REGE.for is a wrapper for calling the FORTRAN subrutine written by White (1985a), modified to be called by R. The REGE does the same, however it is written in R. The functions with and without \".for\" differ only in whether they are implemented in R of FORTRAN. Needless to say, the functions implemented in FORTRAN are much faster.\n\nREGE.ow, REGE.ow.for - The above function, modified so that a best match is searched for each arc separately (and not for both arcs, if they exist, together).\n\nREGE.ownm.for - The above function, modified so that a best match for an outgoing ties is searched on row-normalized network and for incoming ties on column-normalized network.\n\n```{r}\nmat <- as.matrix(igraph::get.adjacency(g)) # Extract the matrix in igraph (if you haven't already)\nD<-blockmodeling::REGE(M=mat)$E\nblockmodeling::plot.mat(mat, clu=cutree(hclust(d=as.dist(1-D),method=\"ward.D\"),k=4))  #REGE returns similarities, which have to be converted to disimilarities\n```\n\n```{r}\n# Try another variation of REGE\nD2<-blockmodeling::REGE.ownm.for(M=mat)$E\nblockmodeling::plot.mat(mat, clu=cutree(hclust(d=as.dist(1-D2),method=\"ward.D\"),k=4))\n```\n\n\n# Practicum: application to militarized interstate disputes\n\nMilitarized interstate disputes are widely thought to be less likely among democratic countries that have high levels of trade and extensive participation in international organizations. \n\nMuch of the statistical association typically reported in this literature apparently stems from three components: a) geographical proximity, b) dependence among militarized interstate disputes with the same initiator or target, and c) the higher-order dependencies in these dyadic data.\n\nOnce these are incorporated, covariates associated with the Kantian peace tripod (democracy, trade, and international governmental organizations) tend to lose most of their statistical power.\n\nDespite high statistical significance and putative substantive importance, none of the variables representing the Kantian tripod is associated with any substantial degree of predictive power.\n\nUsing data from Peterson's 2014 JCR [\"Dyadic Trade, Exist costs and conflict\"](http://sci-hub.se/10.1177/0022002713478794)\n\n**Abstract:**\n\n\"Most studies of the link between dyadic trade and militarized conflict examine the extent of trade interaction. However, interaction measures do not account for the impact of cutting off trade (i.e., exit costs). In this article, I highlight the link between exit costs, the cost of conflict, and “the spoils of conquest,” arguing that one state’s exit costs are associated with higher incidence of dyadic conflict when its trade partner’s exit costs are low. However, its exit costs become less aggravating—and eventually pacifying—as its trade partner’s exit costs increase. I test this argument by estimating import demand and export supply elasticities, developing yearly exit cost measures for directed dyads, 1984–2000. Statistical tests confirm that unilaterally high exit costs are aggravating, but that jointly high exit costs are pacifying, a pattern most prominent for trade in strategic commodities.\"\n\n\n```{r}\npeterson <- rio::import(\"./data/JCR_rep_data.dta\")\n#install.packages(\"countrycode\")\nlibrary(countrycode)\npeterson$cname1 <- countrycode(peterson$ccode1, \"cown\", \"cowc\")\npeterson$cname2 <- countrycode(peterson$ccode2, \"cown\", \"cowc\")\npeterson <- peterson %>% select(ccode1, ccode2, cname1, cname2, year, fcwinit, fcwongo, lndist, fincthc, finctlc, polity1_adj, polity2_adj, polity_int, s_wt_glo)\n```\n\nDescription of variables\n\n- `ccode1`, Correlates of War code number for state 1\n- `ccode2`, Correlates of War code number for state 2\n- `cname1`, Name State 1\n- `cname2`, Name State 2\n- `year`, Year of observation\n- `fcwinit`, MID initiation t+1\n- `fcwongo`, MID ongoing t+1\n- `lndist`, natural log of distance\n- `finctlc`, count of low conflict events t+1\n- `fincthc`, count of high conflict events t+1\n- `polity1_adj`, polity2 combined score for A (+10)\n- `polity2_adj`, polity2 combined score for B (+10)\n- `polity_int`, polity2 interaction of each state's combined democracy–autocracy score(rescaled from 0 to 20) from the Polity IV project\n- `s_wt_glo`, alliance similarity using Signorino and Ritter’s (1999) global weighted S score (accounts for similar foreign policy preferences)\n\n",
    "created" : 1558185540029.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3080103437",
    "id" : "85BD8C60",
    "lastKnownWriteTime" : 1558438462,
    "last_content_update" : 1558438462832,
    "path" : "~/Dropbox/Academic/Teaching/Summer Schools & Workshops/EUI Florence 2019/day2 pm (social capital, brokerage, equivalences)/day2lab/day2lab.Rmd",
    "project_path" : "day2lab.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}